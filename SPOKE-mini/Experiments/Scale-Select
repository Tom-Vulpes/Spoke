# Pins 0 - 3 select the scale to play, the rest play the midi notes


import time
import board
import touchio
import digitalio
import usb_midi
import adafruit_midi
from adafruit_midi.note_on import NoteOn
from adafruit_midi.note_off import NoteOff

# Define the touch pins
touch_pins = [board.GP0, board.GP1, board.GP2, board.GP3, board.GP4, board.GP5, board.GP6, board.GP7, board.GP8, board.GP9, board.GP10, board.GP11, board.GP12, board.GP13, board.GP14, board.GP15, board.GP16, board.GP17, board.GP18, board.GP19, board.GP20, board.GP21, board.GP22, board.GP26, board.GP27, board.GP28]

touch_sensors = []
for pin in touch_pins:
    try:
        touch_sensors.append(touchio.TouchIn(pin))
    except ValueError:
        print(f"No pulldown resistor found on pin {pin}, skipping...")

# MIDI setup
midi = adafruit_midi.MIDI(midi_out=usb_midi.ports[1], out_channel=0)

# Define scales as intervals from a root note (C4 = 60)
# Each scale is a list of semitone offsets from the root
ROOT_NOTE = 60  # C4

SCALES = {
    'chromatic': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],  # Default (no pin held)
    'pentatonic': [0, 2, 4, 7, 9, 12, 14, 16, 19, 21, 24, 26, 28, 31, 33, 36, 38, 40, 43, 45, 48, 50],  # Pin 0
    'major': [0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33, 35, 36],  # Pin 1
    'minor': [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32, 34, 36],  # Pin 2
    'blues': [0, 3, 5, 6, 7, 10, 12, 15, 17, 18, 19, 22, 24, 27, 29, 30, 31, 34, 36, 39, 41, 42]  # Pin 3
}

# Scale selector pins (first 4 pins)
SCALE_SELECTOR_PINS = 4
# Note player pins (remaining pins)
NOTE_PLAYER_START = 4

# State variables
note_played = [False] * len(touch_pins)
current_scale = 'chromatic'

# Setup LED
led = digitalio.DigitalInOut(board.LED)
led.direction = digitalio.Direction.OUTPUT

def get_current_scale():
    """Determine which scale is active based on selector pins"""
    if len(touch_sensors) > 0 and touch_sensors[0].value:
        return 'pentatonic'
    elif len(touch_sensors) > 1 and touch_sensors[1].value:
        return 'major'
    elif len(touch_sensors) > 2 and touch_sensors[2].value:
        return 'minor'
    elif len(touch_sensors) > 3 and touch_sensors[3].value:
        return 'blues'
    else:
        return 'chromatic'

def get_midi_note_for_pin(pin_index):
    """Get the MIDI note for a given pin based on the current scale"""
    note_index = pin_index - NOTE_PLAYER_START
    if note_index < 0 or note_index >= len(SCALES[current_scale]):
        return None
    return ROOT_NOTE + SCALES[current_scale][note_index]

# Main loop
while True:
    # Update current scale based on selector pins
    new_scale = get_current_scale()
    
    # If scale changed, turn off all playing notes
    if new_scale != current_scale:
        for i in range(NOTE_PLAYER_START, len(touch_sensors)):
            if note_played[i]:
                old_note = get_midi_note_for_pin(i)
                if old_note:
                    midi.send(NoteOff(old_note, 0))
                note_played[i] = False
        current_scale = new_scale
    
    # Process note player pins (skip the first 4 selector pins)
    for i in range(NOTE_PLAYER_START, len(touch_sensors)):
        touch_sensor = touch_sensors[i]
        midi_note = get_midi_note_for_pin(i)
        
        if midi_note is None:
            continue
        
        # Capacitive touch sensing
        if touch_sensor.value:
            # Check if the note has already been played
            if not note_played[i]:
                # Send MIDI note on message when touch is detected
                midi.send(NoteOn(midi_note, 120))
                led.value = True
                note_played[i] = True
        else:
            # Check if the note has been played and turn it off
            if note_played[i]:
                # Send MIDI note off message when touch is released
                midi.send(NoteOff(midi_note, 0))
                led.value = False
                note_played[i] = False
    
    # Small delay to prevent excessive CPU usage
    time.sleep(0.01)
